package  {		import flash.display.MovieClip;	import flash.events.MouseEvent;	import flash.display.MovieClip;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.ui.Keyboard;	import flash.external.ExternalInterface;	import flash.utils.getQualifiedClassName;	import flash.display.Loader;	import flash.display.Bitmap;	import flash.net.URLRequest;	import flash.system.Security;	import fl.data.DataProvider;	import fl.controls.ComboBox;			public class SavePrincessBobGame extends MovieClip {		/*navigation between title screen, levels, and the setup menu accomplished		by changing frames on the main stage. */				public function SavePrincessBobGame() {			//prevents auto-animating.  Maybe...			this.stop();			//buttons			_makeYourOwn.addEventListener(MouseEvent.CLICK, setupGame);			_startButton.addEventListener(MouseEvent.CLICK, startGameWrapper);						// Allows us to load Facebook Profile images from Facebook's CDN (content delivery network).			// For more information, check out this thread on StackOverflow:			// 	  http://stackoverflow.com/questions/3965214/load-profile-image-from-facebook-with-actionscript-3			Security.loadPolicyFile("https://fbcdn-profile-a.akamaihd.net/crossdomain.xml");		}				private function changeLevel(n:Number):void		{			this.gotoAndStop(n);		}				// Print flash errors in Chrome.		public static function log(msg:String, caller:Object = null):void{			var str:String = "";			if(caller){				str = getQualifiedClassName(caller);				str += ":: ";			}			str += msg;			trace(str);			if(ExternalInterface.available){				// The called function, l(), calls console.log() if it is defined.				ExternalInterface.call("l",str); 			}		}				//the wrapper allows a button to call startGame, as well as any function that doesn't have an event to send in.		function startGameWrapper(event:MouseEvent):void {			startGame();		}				function startGame():void {			changeLevel(3);			initializeGame();		}				////////////////////////////////////////////////////////////////////////////////////////////////////////		//		// Setup - Choose friends and adjust their pictures.		//		////////////////////////////////////////////////////////////////////////////////////////////////////////			public var _heroPreview:CharPreview;		public var _char1Preview:CharPreview;		public var _char2Preview:CharPreview;		public var _char3Preview:CharPreview;		public var _char4Preview:CharPreview;		public var _heroFaceList:Array;		var _mouseDown:Boolean;		var _oldPicX:Number;		var _oldPicY:Number;						//the pixel_change in a picture that will register (NOT SURE IF STILL NECESSARY)		const PIC_EPSILON:Number = 20;				// Run the game setup, choose characters, etc.		function setupGame(event:MouseEvent):void		{			changeLevel(2);						// The current user's facebook id.  The current user will be the hero.			var myFacebookId = getUserFacebookId();			var myName = getUserName();						// The elements of the friends array can be accessed like this:			//   var friend = friends[0];			//   var friend_name = friend.name;  // Stephanie Brinton Parker			//   var friend_facebook_id = friend.id;  // 34800			var friends = getFacebookFriends();			// Choose 4 friends			shuffleArray(friends);			var chosenFriends = friends.slice(0, 4);			// Sort by name alphabetically			sortArrayByFriendName(friends);						// Initialize hero face widget			initializeFaceWidget(facebookIdToImageUrl(myFacebookId), myName, friends, {				preview : _heroPreview,				nameLabel : _heroNameLabel,				zoomIn : _heroZoomIn,				zoomOut : _heroZoomOut,				rotateCW : _heroRotateCW,				rotateCCW : _heroRotateCCW			});						// Initialize character face widgets			for (var i = 0; i < chosenFriends.length; i++) {				var num = i + 1;				var friend = chosenFriends[i];				initializeFaceWidget(facebookIdToImageUrl(friend.id), friend.name, friends, {					preview : this["_char" + num + "Preview"],					dropDown : this["_char" + num + "DropDown"],					zoomIn : this["_char" + num + "ZoomIn"],					zoomOut : this["_char" + num + "ZoomOut"],					rotateCW : this["_char" + num + "RotateCW"],					rotateCCW : this["_char" + num + "RotateCCW"]				});			}						//POTENTIAL BUG: you might need to clear these stage listeners once you enter the game.			stage.addEventListener(MouseEvent.MOUSE_UP, mouseDownFalse);			_doneSetup.addEventListener(MouseEvent.CLICK, doneSetup);						_mouseDown = false;		}				// TODO: Implement dropdown change photo				// Initialize the event listeners and download the image for the given widget		function initializeFaceWidget(imageUrl, faceName, friends, widget) {			var photo = widget.preview._photo;			if (widget.nameLabel) widget.nameLabel.text = faceName;			if (widget.dropDown) {				var friendNames = getFriendNamesForDataProvider(friends);				widget.dropDown.dataProvider = new DataProvider(friendNames);				widget.dropDown.selectedIndex = getFriendIndexOf(friends, faceName);			}						// Download image			var myLoader:Loader = new Loader();			var url:URLRequest = new URLRequest(imageUrl);			myLoader.contentLoaderInfo.addEventListener(Event.COMPLETE, onImageLoaded(photo));			myLoader.load(url);						// Initialize event listeners			widget.zoomIn.addEventListener(MouseEvent.CLICK, picZoomIn(photo));			widget.zoomOut.addEventListener(MouseEvent.CLICK, picZoomOut(photo));			widget.rotateCW.addEventListener(MouseEvent.CLICK, picRotateCW(photo));			widget.rotateCCW.addEventListener(MouseEvent.CLICK, picRotateCCW(photo));			widget.preview.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownTrue);			widget.preview.addEventListener(MouseEvent.MOUSE_MOVE, movePic(photo));		}				// Return the index of friend with the specified name in the friends array.		// Return -1 if not found.		function getFriendIndexOf(friends, friendName) {			for (var i = 0; i < friends.length; i++) {				if (friends[i].name == friendName) return i;			}			return -1;		}				// Create an array of friend names, consumable by a ComboBox's DataProvider.		// The array will have this format : 		// [{ label: "Cliff Crosland", data: "<Cliff's facebook id>" }, ... ]		function getFriendNamesForDataProvider(friends:Array):Array {			var friendNames = [];			for (var i = 0; i < friends.length; i++) {				var friendNameEntry = { label : friends[i].name, data : friends[i].id };				friendNames.push(friendNameEntry);			}			return friendNames;		}				// Return the current user's facebook id. If testing locally in flash player, return		// Jonathan Pulsipher's facebook ID.		function getUserFacebookId() {			var facebookId = ExternalInterface.call("window.SavePrincessBob.getUserFacebookId");			if (!facebookId) {				return "225547"; // Jonathan Pulsipher's facebook ID			} else {				return facebookId;			}		}				// Return the current user's name.  If testing locally, return "Jonathan Pulsipher".		function getUserName() {			var userName = ExternalInterface.call("window.SavePrincessBob.getUserName");			if (!userName) {				return "Jonathan Pulsipher"; // Jonathan Pulsipher's facebook ID			} else {				return userName;			}		}				// Return the current user's facebook friends.  If testing locally in flash player, return		// some of Jon's and Cliff's friends.		function getFacebookFriends() {			var friends = ExternalInterface.call("window.SavePrincessBob.getFriendsArray");			if (!friends) {				return [{"id":"221843", "name":"Cliff Crosland"},				 		{"id":"223517", "name":"Sam Pimentel"},				 		{"id":"210010", "name":"Jeff Brown"},				 		{"id":"17803162", "name":"Katie Pulsipher Brown"}];			} else {				return friends;			}		}				// Given a facebook id, returns the url to the profile picture.		function facebookIdToImageUrl(facebookId:String):String {			return "https://graph.facebook.com/" + facebookId + "/picture?type=large";		}				// Pick a random integer between low and high, inclusive		function randomInt(low:Number, high:Number) {			return Math.floor(Math.random() * (1 + high - low)) + low;		}				// Shuffle the specified array in-place.		function shuffleArray(array:Array) {			for (var i:Number = 0; i < array.length; i++) {				var randElem = randomInt(i, array.length - 1);				var temp = array[i];				array[i] = array[randElem];				array[randElem] = temp;			}		}				// Sort the array by friend name		function sortArrayByFriendName(array:Array) {			array.sort(function (a, b):int {				if (a.name == b.name) return 0;				if (a.name < b.name) return -1;				return 1;			});		}				// ----------- Widget event functions ----------- //		// When the image is loaded, add it to the specified photo		function onImageLoaded(photo):Function {			return function(e:Event):void {				var image:Bitmap = new Bitmap(e.target.content.bitmapData);				image.x = -image.width/2;				image.y = -image.height/2;				photo.addChild(image);			};		}				// On zoom-in click		function picZoomIn(photo):Function {			return function (event:MouseEvent):void {				photo.getChildAt(1).scaleX += 0.1;				photo.getChildAt(1).scaleY += 0.1;			};		}				// On zoom-out click		function picZoomOut(photo):Function {			return function (event:MouseEvent):void {				photo.getChildAt(1).scaleX -= 0.1;				photo.getChildAt(1).scaleY -= 0.1;			};		}				// On rotate clockwise click		function picRotateCW(photo):Function {			return function (event:MouseEvent):void {				photo.getChildAt(1).rotation += 2;			};		}				// On rotate counter-clockwise click		function picRotateCCW(photo):Function {			return function(event:MouseEvent):void {				photo.getChildAt(1).rotation -= 2;			};		}				// On mouse down		function mouseDownTrue(event:MouseEvent):void { 			_mouseDown = true;			_oldPicX = event.localX;			_oldPicY = event.localY;		}				// On mouse up		function mouseDownFalse(event:MouseEvent):void { _mouseDown = false; }				// On mouse move, if the mouse is down, move the picture.		function movePic(photo):Function {			return function(event:MouseEvent):void {				if(_mouseDown){					var _newPicX:Number = event.localX;					var _newPicY:Number = event.localY;					var Xchange = _newPicX - _oldPicX;					var Ychange = _newPicY - _oldPicY;					if(Math.abs(Xchange) < PIC_EPSILON && Math.abs(Ychange) < PIC_EPSILON){						photo.getChildAt(1).x += (Xchange);						photo.getChildAt(1).y += (Ychange);						_oldPicX = _newPicX;						_oldPicY = _newPicY;					}				}			};		}						function doneSetup(event:MouseEvent):void		{			//eventually this array will set the faces for all characters (5)			_heroFaceList = new Array();			_heroFaceList[0] = _heroPreview._photo.getChildAt(1);			for (var num = 1; num <= 4; num++) {				var charPreview = this["_char" + num + "Preview"];				var charPhoto = charPreview._photo.getChildAt(1);				_heroFaceList[num] = charPhoto;			}			startGame();		}										//game code				public var _hero:BaseBody;		public var _boundaries:Boundaries;		public var _startMarker:StartMarker;				private var _vx:Number;		private var _vy:Number;		private var _movingLeft:Boolean;		private var _movingRight:Boolean;		private var _jumping:Boolean;		private var _holdingJump:Boolean;				function initializeGame():void		{			faceTheHeroes();			_startMarker.visible = false;			_vx = 0;			_vy = 0;			_movingLeft = false;			_movingRight = false;			_jumping = false;			_holdingJump = false;			stage.focus = stage;						//add event listeners			this.addEventListener(Event.ENTER_FRAME, enterFrameHandler);			stage.addEventListener(KeyboardEvent.KEY_DOWN, keyDownHandler);			stage.addEventListener(KeyboardEvent.KEY_UP, keyUpHandler);		}				//add faces from setup to each hero		function faceTheHeroes():void		{			if(_heroFaceList){				_hero._heroHead.addChild(_heroFaceList[0]);			}		}				private function enterFrameHandler(e:Event):void		{			//gravitate the player			if(!_boundaries.hitTestPoint(_hero.x, _hero.y, true)){			   if(!(_holdingJump && _vy < 0)) _vy += 2;				else _vy += 1;			} 						//move the player			_hero.x += _vx;			_hero.y += _vy;						if(!_movingLeft && !_movingRight){				_vx *= 0.7;				if(!_jumping) _hero.gotoAndStop(1);			}			else if(_vx > -14 && _vx < 14) _vx *=1.5;							if(_hero.currentFrame == 35)_hero.gotoAndPlay(11);			else if(_hero.currentFrame == 60) _hero.gotoAndPlay(36);						//process collisions			processCollisions();						//scroll the stage			//scrollStage();		}				private function keyDownHandler(e:KeyboardEvent):void		{			switch (e.keyCode)			{				case 37: //left_arrow				if(_hero.scaleX > 0){					_hero.scaleX *= -1;				}				//if(_vx > -16) _vx -= 5;				if(!_movingLeft) _hero.gotoAndPlay(11);				_movingLeft = true;				if(_vx > -4) _vx = -3;				//_vx = -15;				break;								case 38: //up arrow				if(!_jumping){					_vy = -14;				} 				if(!_jumping)_hero.gotoAndPlay(36);				_jumping = true;				_holdingJump = true;				break;								case 39: //right_arrow				if(_hero.scaleX < 0){					_hero.scaleX *= -1;				}				//if(_vx < 16) _vx += 5;				if(!_movingRight) _hero.gotoAndPlay(11);				_movingRight = true;								if(_vx < 4) _vx = 3;				//_vx = 15;				break;								case 65:				//for the attack animation								default:			}		}				private function keyUpHandler(e:KeyboardEvent):void		{			switch (e.keyCode)			{												case 38: //up arrow					_holdingJump = false;				break;								case 37: //left_arrow					_movingLeft = false;				break;								case 39: //right_arrow					_movingRight = false;				break;								default:			}		}				private function scrollStage():void		{			//you could use some awesome for loop to call this on 			//every stage object except the hero.			_boundaries.x += (stage.stageWidth * 0.5) - _hero.x;			_boundaries.y += (stage.stageHeight * 0.5) - _hero.y;			//__startMarker.x += (stage.stageWidth * 0.5) - _hero.x;			//__startMarker.y += (stage.stageHeight * 0.5) - _hero.y;			_hero.x = stage.stageWidth * 0.5;			_hero.y = stage.stageHeight * 0.5;		}				private function processCollisions():void		{			//when player is falling			if(_vy > 0)			{				//respawn if player fell off the stage				if (_hero.y > stage.stageHeight)				{					_hero.x = _startMarker.x;					_hero.y = _startMarker.y;					_boundaries.x = 0;  // you will have to start with a strangely displayced boundary for this to reset it correctly.					_boundaries.y = 0;					_vy = 0;				}				//otherwise, process collisions with boundaries				else				{					var groundCollision:Boolean = false;					var wallCollision:Boolean = false;										//ground, checking bottom right and bottom left					if(_boundaries.hitTestPoint(_hero.x, _hero.y, true)){						groundCollision = true;					}					if(_boundaries.hitTestPoint(_hero.x + _hero.width/2, _hero.y - _hero.height/2))					{						wallCollision = true;						}										if (groundCollision)					{						while(groundCollision)						{							_hero.y -= 0.1;							if(!_boundaries.hitTestPoint(_hero.x, _hero.y, true)){								groundCollision = false;							}						}						_jumping = false;						_vy = 0;					}										//turning this off for a second because wallcoll isn't working					/*					if (wallCollision)					{						while(wallCollision)						{							if(_movingRight)_hero.x -= 0.1;							else _hero.x += 0.1;							if(!_boundaries.hitTestPoint(_hero.x + _hero.width/2, _hero.y - _hero.height/2, true)){								wallCollision = false;							}						}						_vx = 0;					}					*/				}			}			}	}}